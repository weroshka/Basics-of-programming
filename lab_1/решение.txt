Расчет сложности алгоритма дублирования четного числа

Лучший случай

Когда все числа в последовательности оказались нечетными:

1. Сложность отдельно взятого алгоритма установления четности числа isEven равна Тета(1)

if (x % 2 == 0)
			return true;

		return false;


2. Далее считаем сложность нижеприведенного алгоритма:

while (i < n)
	{
		if (standart::isEven(mas[i]))
		{
			for (int k = n - 1; k >= i; k--)
			{
				mas[k + 1] = mas[k];

			}
			n++;
			i++;
		}
		i++;
	}

Цикл while выполнятеся n раз + n раз происходит вызов функции isEven, которая, в свою очередь, обрабатывает n чисел. Цикла for не выполняется в лучшем 
случае.
 
Итого: 3n, что приближенно равно n. Сложность алгоритма = Тета(n)

Худший случай

Когда все числа в последовательности оказались четными, и они все будут дублироваться.

К вышеприведенному расчету добавляется еще и выполнение цикла for + операции в теле цикла for. Итого, отбросив константы и множители,
получаем n*n = n^2.
Сложность алгоритма в лучшем случае = Тета(n^2)

Время выполнения 
 в лучшем случае для n = 1000: 1000/1 000 000 000 м/с = 1*10^(-6) сек
 в худшем случае для n = 20: (20*20)/1 000 000 000 м/с = 4*10^(-7) сек